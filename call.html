<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ThunderChat Call</title>
    <style>
        /* CSS Variables for Theming (Assuming these are defined in your main styles.css or similar) */
        /* For standalone call.html, you might want to define a minimal set here or ensure main styles.css is linked */
        :root {
            --primary-color: #0A84FF; /* iOS Blue */
            --primary-color-dark: #005A9C; /* Deeper Blue for hover/active */
            --secondary-accent: #34C759; /* Green for success/positive actions */
            --danger-color: #FF3B30; /* Red for errors/destructive actions */

            --background-light: #F2F2F7;
            --background-dark: #000000;
            --surface-light: #FFFFFF;
            --surface-dark: #1C1C1E;
            --text-primary-light: #000000;
            --text-primary-dark: #FFFFFF;
            --text-secondary-light: #6A6A6A;
            --text-secondary-dark: #8E8E93;
            --border-light: #E5E5EA;
            --border-dark: #3A3A3C;

            --color-cyan-dark: #00838f;
            --color-cyan-primary: #00bcd4;
            --color-cyan-light: #80deea;

            /* Spacing */
            --spacing-xxs: 4px;
            --spacing-xs: 8px;
            --spacing-sm: 12px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 48px;

            /* Font Sizes */
            --font-size-body: 16px;
            --font-size-subheadline: 14px;
            --font-size-footnote: 12px;
            --font-size-headline: 17px;
            --font-size-title2: 22px;

            /* Font Weights */
            --font-weight-regular: 400;
            --font-weight-medium: 600;
            --font-weight-bold: 700;

            /* Border Radius */
            --border-radius-sm: 6px;
            --border-radius-md: 10px;
            --border-radius-lg: 14px;
            --border-radius-xl: 20px;

            /* Transitions */
            --transition-duration-normal: 0.3s ease-in-out;
            --transition-duration-fast: 0.15s ease-out;
        }

        /* Global Reset & Base Styles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background: var(--background-light);
            color: var(--text-primary-light);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background var(--transition-duration-normal), color var(--transition-duration-normal);
        }

        body.dark-theme {
            background: var(--background-dark);
            color: var(--text-primary-dark);
        }

        button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            font-family: 'Inter', sans-serif;
            transition: opacity 0.3s ease;
        }

        button:hover {
            opacity: 0.8;
        }

        button:active {
            opacity: 0.6;
        }

        .hidden {
            display: none !important;
        }

        .app-section {
            width: 100%;
            max-width: 600px; /* Max width for app sections */
            height: 100vh; /* Full viewport height for mobile app feel */
            display: flex;
            flex-direction: column;
            background: var(--surface-light);
            border-radius: 0; /* No border-radius on mobile for full screen effect */
            box-shadow: none; /* No shadow on mobile */
            overflow: hidden;
            position: relative; /* For absolute positioning of sub-elements */
        }

        /* call.css - Styling for the Real-time Calling Interface */

        /* Call Screen Container */
        .call-screen {
            background: linear-gradient(135deg, var(--color-cyan-dark) 0%, #005a64 100%); /* Darker, more immersive background */
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            position: absolute; /* Occupy full space within main-sections-container */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* Ensure it's on top of other sections */
            transition: transform var(--transition-duration-normal) ease-out, opacity var(--transition-duration-normal) ease-out;
        }

        /* Call Header */
        .call-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            background: rgba(0, 0, 0, 0.2); /* Semi-transparent background */
            border-radius: var(--border-radius-md);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .call-header .back-btn {
            color: white;
            font-size: 1.8em;
            padding: var(--spacing-xs);
        }

        .call-header h2 {
            font-size: var(--font-size-title2);
            font-weight: var(--font-weight-bold);
            margin: 0;
            flex-grow: 1;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }

        .call-status {
            font-size: var(--font-size-subheadline);
            color: var(--color-cyan-light);
            font-weight: var(--font-weight-medium);
            text-align: right;
            min-width: 80px; /* Ensure space for status text */
        }

        /* Video Containers */
        .video-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Take up available space */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.4); /* Dark background for videos */
            border-radius: var(--border-radius-lg);
            overflow: hidden;
            margin-bottom: var(--spacing-xl);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensure entire video is visible */
            background-color: black;
            display: block; /* Always display, but content might be empty */
            border-radius: var(--border-radius-lg);
        }

        .local-video {
            position: absolute;
            bottom: var(--spacing-md);
            right: var(--spacing-md);
            width: 120px; /* Smaller local video */
            height: 90px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid white;
            border-radius: var(--border-radius-md);
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s ease-in-out;
            z-index: 10; /* Ensure local video is above remote */
        }

        /* Call Controls */
        .call-controls {
            display: flex;
            justify-content: center;
            gap: var(--spacing-xl); /* More space between buttons */
            width: 100%;
            padding: var(--spacing-md);
            background: rgba(0, 0, 0, 0.2); /* Semi-transparent background */
            border-radius: var(--border-radius-lg);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15); /* Lighter transparent background */
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: white;
            width: 60px; /* Larger buttons */
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em; /* Larger icons */
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .control-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .hangup-btn {
            background: var(--danger-color); /* Red for hangup */
            border-color: var(--danger-color);
        }

        .hangup-btn:hover {
            background: var(--danger-color); /* No darken function in plain CSS */
            filter: brightness(0.9); /* Simulate darken */
            border-color: var(--danger-color);
        }

        .control-btn.off {
            background: rgba(255, 255, 255, 0.05); /* Very light transparent when off */
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5); /* Faded color when off */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); /* Inner shadow for "off" state */
        }

        .control-btn.off:hover {
            transform: none;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            background: rgba(255, 255, 255, 0.08);
        }

        /* Responsive Adjustments */
        @media (min-width: 601px) {
            .app-section {
                border-radius: var(--border-radius-lg);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                height: 85vh; /* Fixed height for desktop app-like feel */
                margin: var(--spacing-xxl) auto; /* Center on desktop */
            }
        }

        @media (max-width: 768px) {
            .call-screen {
                padding: var(--spacing-sm);
            }
            .call-header {
                padding: var(--spacing-xs);
            }
            .call-header h2 {
                font-size: var(--font-size-headline);
            }
            .call-status {
                font-size: var(--font-size-footnote);
            }
            .local-video {
                width: 100px;
                height: 75px;
                bottom: var(--spacing-sm);
                right: var(--spacing-sm);
            }
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5em;
            }
            .call-controls {
                gap: var(--spacing-md);
                padding: var(--spacing-sm);
            }
        }

        @media (max-width: 480px) {
            .call-screen {
                padding: var(--spacing-xs);
            }
            .call-header h2 {
                font-size: var(--font-size-body);
            }
            .local-video {
                width: 80px;
                height: 60px;
                border-width: 1px;
            }
            .control-btn {
                width: 45px;
                height: 45px;
                font-size: 1.3em;
            }
            .call-controls {
                gap: var(--spacing-sm);
                padding: var(--spacing-xs);
            }
        }

        /* Dark Theme Overrides for Call Screen */
        body.dark-theme .call-screen {
            background: linear-gradient(135deg, #1a2226 0%, #000000 100%); /* Even darker gradient */
        }

        body.dark-theme .call-header {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        body.dark-theme .call-header h2,
        body.dark-theme .call-status {
            color: var(--text-primary-dark);
        }

        body.dark-theme .video-container {
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.2);
        }

        body.dark-theme .local-video {
            border-color: var(--border-dark);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        body.dark-theme .call-controls {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.5);
        }

        body.dark-theme .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: var(--text-primary-dark);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        body.dark-theme .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        body.dark-theme .hangup-btn {
            background: var(--danger-color);
            border-color: var(--danger-color);
        }

        body.dark-theme .control-btn.off {
            background: rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="call-screen" class="call-screen app-section hidden">
        <div class="call-header">
            <button class="back-btn" id="back-from-call-btn">←</button>
            <h2 id="remote-user-display"></h2>
            <div class="call-status" id="call-status">Connecting...</div>
        </div>
        <div class="video-container">
            <video id="local-video" autoplay muted playsinline class="local-video"></video>
            <video id="remote-video" autoplay playsinline class="remote-video"></video>
        </div>
        <div class="call-controls">
            <button id="toggle-mic-btn" class="control-btn mic-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
            </button>
            <button id="hangup-btn" class="control-btn hangup-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-phone-off"><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.66 1.66a3 3 0 0 1 0 4.24l-2.34 2.34a3 3 0 0 1-4.24 0l-.01-.01c-.34-.34-.67-.67-1-1l-2.34-2.34a3 3 0 0 1 0-4.24l1.66-1.66c.8-.79 2.19-1.18 3.51-1.03Z"/><path d="M19.95 4.05A10 10 0 0 0 12 2a10 10 0 0 0-9.95 9.95"/><path d="M22 6c0 2.72-1.06 5.23-2.75 7.16"/><line x1="2" x2="22" y1="2" y2="22"/></svg>
            </button>
            <button id="toggle-video-btn" class="control-btn video-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video"><path d="M22 8.5V12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8.5L10 2l12 6.5Z"/><path d="M2 12v3.5A2.5 2.5 0 0 0 4.5 18h15A2.5 2.5 0 0 0 22 15.5V12"/></svg>
            </button>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules for this self-contained HTML
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
        import {
            getAuth,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            onAuthStateChanged,
            signOut,
        } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";
        import {
            getDatabase,
            ref,
            push,
            onChildAdded,
            update,
            onValue,
            remove,
            set,
            get,
            child
        } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-database.js";

        // Your Firebase config here (ensure this matches your project's config)
        const firebaseConfig = {
            apiKey: "AIzaSyBD4bDQgVtMd9cwq9Hfdz54NYSBcQvPr1Y",
            authDomain: "thunderboundthunderchat.firebaseapp.com",
            databaseURL:
                "https://thunderboundthunderchat-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "thunderboundthunderchat",
            storageBucket: "thunderboundthunderchat.appspot.com",
            messagingSenderId: "79690962383",
            appId: "1:79690962383:web:fecf12881a13a4fdf22eba",
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // Global variables (mimicking what main.js might provide)
        // In a real scenario, these would ideally be passed or managed via a shared module.
        // For this self-contained file, we'll simulate them.
        let currentUser = null; // Will be populated by onAuthStateChanged
        
        // Mock utility functions if this file is run truly standalone.
        // In your integrated app, these would come from main.js.
        const loadingScreen = { style: { display: 'none' }, querySelector: () => ({ textContent: '' }) }; // Mock
        const authSection = { style: { display: 'none' } }; // Mock
        const groupOptions = { style: { display: 'none' } }; // Mock
        const chatSection = { style: { display: 'none' } }; // Mock
        const contactsSection = { style: { display: 'none' } }; // Mock
        const privateChatSection = { style: { display: 'none' } }; // Mock
        const postsSection = { style: { display: 'none' } }; // Mock
        const postsStudioSection = { style: { display: 'none' } }; // Mock
        const settingsSection = { style: { display: 'none' } }; // Mock

        // Custom Alert Modal functions (minimal implementation for standalone)
        const customAlertModal = document.createElement('div');
        customAlertModal.id = 'custom-alert-modal';
        customAlertModal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center;
            z-index: 9999;
        `;
        const customAlertContent = document.createElement('div');
        customAlertContent.style.cssText = `
            background: white; padding: 20px; border-radius: 8px; text-align: center;
            max-width: 300px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        `;
        const customAlertMessage = document.createElement('div');
        customAlertMessage.id = 'custom-alert-message';
        const customAlertOkBtn = document.createElement('button');
        customAlertOkBtn.textContent = 'OK';
        customAlertOkBtn.style.cssText = `
            margin-top: 15px; padding: 8px 15px; background: var(--primary-color); color: white;
            border: none; border-radius: 5px; cursor: pointer;
        `;
        customAlertOkBtn.onclick = () => customAlertModal.style.display = 'none';
        customAlertContent.appendChild(customAlertMessage);
        customAlertContent.appendChild(customAlertOkBtn);
        customAlertModal.appendChild(customAlertContent);
        document.body.appendChild(customAlertModal);

        window.showAlert = function(title, message, duration = 3000) {
            customAlertMessage.innerHTML = `<h4>${title}</h4><p>${message}</p>`;
            customAlertModal.style.display = 'flex';
            if (duration > 0) {
                setTimeout(() => customAlertModal.style.display = 'none', duration);
            }
        };

        window.showPrompt = function(title, message, showInput = true, confirmText = "Confirm", cancelText = "Cancel") {
            return new Promise((resolve) => {
                customAlertMessage.innerHTML = `<h4>${title}</h4><p>${message}</p>`;

                let inputElement = null;
                if (showInput) {
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.placeholder = 'Enter value';
                    inputElement.style.cssText = `
                        width: 100%; padding: 8px; margin-top: 10px; border: 1px solid #ccc; border-radius: 4px;
                    `;
                    customAlertMessage.appendChild(inputElement);
                }

                const actionsDiv = document.createElement('div');
                actionsDiv.style.cssText = `
                    margin-top: 15px; display: flex; justify-content: center; gap: 10px;
                `;

                const confirmButton = document.createElement('button');
                confirmButton.textContent = confirmText;
                confirmButton.style.cssText = `
                    padding: 8px 15px; background: var(--primary-color); color: white; border: none; border-radius: 5px; cursor: pointer;
                `;
                actionsDiv.appendChild(confirmButton);

                const cancelButton = document.createElement('button');
                cancelButton.textContent = cancelText;
                cancelButton.style.cssText = `
                    padding: 8px 15px; background: #ccc; color: black; border: none; border-radius: 5px; cursor: pointer;
                `;
                actionsDiv.appendChild(cancelButton);

                customAlertMessage.appendChild(actionsDiv);
                customAlertModal.style.display = 'flex';

                const cleanup = () => {
                    confirmButton.removeEventListener('click', onConfirm);
                    cancelButton.removeEventListener('click', onCancel);
                    customAlertModal.style.display = 'none';
                    customAlertMessage.innerHTML = '';
                };

                const onConfirm = () => {
                    cleanup();
                    resolve(showInput ? inputElement.value : true);
                };

                const onCancel = () => {
                    cleanup();
                    resolve(false);
                };

                confirmButton.addEventListener('click', onConfirm);
                cancelButton.addEventListener('click', onCancel);
            });
        };

        window.showLoading = function(message = 'Loading...') {
            loadingScreen.style.display = 'flex';
            loadingScreen.querySelector('.loading-text').textContent = message;
        };

        window.hideLoading = function() {
            loadingScreen.style.display = 'none';
        };

        window.showSection = function(sectionId) {
            const sections = [
                document.getElementById('call-screen'),
                // Add other sections if needed for full app context
                // For a standalone call.html, only call-screen needs to be managed
            ];
            sections.forEach(section => {
                if (section && section.id === sectionId) {
                    section.style.display = 'flex';
                } else if (section) {
                    section.style.display = 'none';
                }
            });
        };

        // WebRTC Global Variables
        let peerConnection = null;
        let localStream = null;
        let currentCallId = null; // ID of the active call in Firebase
        let callType = null; // 'voice' or 'video'
        let callRef = null; // Firebase reference to the current call
        let callEndedListener = null; // Listener for call ending
        let isMicMuted = false;
        let isVideoOff = false;

        // WebRTC Configuration (using Google's STUN server for NAT traversal)
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
            ]
        };

        // DOM Elements for Call UI (these IDs should match call.html)
        const callScreen = document.getElementById('call-screen');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const callStatus = document.getElementById('call-status');
        const remoteUserDisplay = document.getElementById('remote-user-display');
        const toggleMicBtn = document.getElementById('toggle-mic-btn');
        const toggleVideoBtn = document.getElementById('toggle-video-btn');
        const hangupBtn = document.getElementById('hangup-btn');
        const backFromCallBtn = document.getElementById('back-from-call-btn');

        /**
         * Helper function to get local media stream (audio and optionally video).
         * @param {boolean} video - Whether to request video track.
         * @returns {Promise<MediaStream|null>} - Resolves with MediaStream or null if error.
         */
        async function getLocalStream(video = true) {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: video,
                    audio: true
                });
                localVideo.srcObject = localStream;
                // Show local video only if it's a video call, otherwise hide it.
                localVideo.style.display = video ? 'block' : 'none';
                // Show video toggle button only if it's a video call.
                toggleVideoBtn.style.display = video ? 'flex' : 'none';
                
                // Reset mic and video button states
                toggleMicBtn.classList.remove('off');
                toggleVideoBtn.classList.remove('off');
                isMicMuted = false;
                isVideoOff = false;
                console.log("Local stream obtained.");
                return localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                showAlert("Media Error", "Could not access microphone or camera. Please check permissions.");
                return null;
            }
        }

        /**
         * Helper function to stop local media stream tracks.
         */
        function stopLocalStream() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                console.log("Local stream stopped.");
            }
        }

        /**
         * Creates and configures a new RTCPeerConnection.
         * Handles ICE candidates and remote tracks.
         * @returns {RTCPeerConnection} - The created peer connection.
         */
        function createPeerConnection() {
            // Close any existing peer connection before creating a new one
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            peerConnection = new RTCPeerConnection(rtcConfig);
            console.log("RTCPeerConnection created.");

            // Add local stream tracks to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    console.log(`Added local track: ${track.kind}`);
                });
            }

            // Event handler for ICE candidates (network information)
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log("Sending ICE candidate:", event.candidate);
                    // Push ICE candidate to Firebase for the other peer to receive
                    if (currentCallId && callRef && currentUser && currentUser.uid) {
                        // Using Firebase Realtime Database's push to add candidates
                        push(ref(db, `calls/${currentCallId}/candidates/${currentUser.uid}`), event.candidate.toJSON());
                    }
                }
            };

            // Event handler for remote tracks (audio/video from the other peer)
            peerConnection.ontrack = (event) => {
                console.log("Received remote track:", event.streams[0]);
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block'; // Ensure remote video is visible
                    callStatus.textContent = 'Connected!';
                    console.log("Remote stream connected.");
                }
            };

            // Event handler for connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log("Peer connection state:", peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    showAlert("Call Ended", "The call has been disconnected.");
                    hangupCall(); // Automatically hang up if connection fails
                } else if (peerConnection.connectionState === 'connected') {
                    callStatus.textContent = 'Connected!';
                }
            };

            // Event handler for ICE connection state changes (more granular network status)
            peerConnection.oniceconnectionstatechange = () => {
                console.log("ICE connection state:", peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
                    // Can add more sophisticated error handling or re-connection logic here
                }
            };

            return peerConnection;
        }

        /**
         * Initiates an outgoing call to a target user.
         * @param {string} targetUsername - The username of the person to call.
         * @param {'voice'|'video'} type - The type of call ('voice' or 'video').
         */
        window.startOutgoingCall = async function(targetUsername, type) {
            if (!currentUser || !currentUser.uid) {
                showAlert("Error", "You must be logged in to make a call.");
                return;
            }

            if (currentCallId) {
                showAlert("Error", "You are already in a call.");
                return;
            }

            showLoading("Initiating call...");
            callType = type;

            try {
                // Find the target user's UID using their username (or memorableId)
                const usersSnapshot = await get(ref(db, 'users'));
                let targetUser = null;
                if (usersSnapshot.exists()) {
                    usersSnapshot.forEach(childSnapshot => {
                        const user = childSnapshot.val();
                        if (user.username.toLowerCase() === targetUsername.toLowerCase() || user.memorableId === targetUsername) {
                            targetUser = { uid: childSnapshot.key, ...user };
                            return true; // Break forEach loop
                        }
                    });
                }

                if (!targetUser) {
                    hideLoading();
                    showAlert("User Not Found", `User "${targetUsername}" does not exist.`);
                    return;
                }

                if (targetUser.uid === currentUser.uid) {
                    hideLoading();
                    showAlert("Self-Call", "You cannot call yourself.");
                    return;
                }

                // 1. Get local media stream
                if (!await getLocalStream(type === 'video')) {
                    hideLoading();
                    return; // Failed to get stream, abort call
                }

                // 2. Create RTCPeerConnection
                createPeerConnection();

                // 3. Create SDP offer
                const offer = await peerConnection.createOffer({
                    offerToReceiveVideo: type === 'video',
                    offerToReceiveAudio: true
                });
                await peerConnection.setLocalDescription(offer);
                console.log("Created and set local offer.");

                // 4. Store call information in Firebase Realtime Database
                // We use push() to generate a unique ID for the call
                const newCallRef = push(ref(db, 'calls'));
                currentCallId = newCallRef.key; // Store the generated call ID
                callRef = newCallRef; // Store the Firebase reference

                await set(newCallRef, {
                    callerId: currentUser.uid,
                    callerUsername: currentUser.username,
                    calleeId: targetUser.uid,
                    calleeUsername: targetUser.username,
                    offer: {
                        type: offer.type,
                        sdp: offer.sdp,
                    },
                    type: type, // 'voice' or 'video'
                    timestamp: Date.now(),
                    status: 'ringing' // Initial status
                });
                console.log("Call created in Firebase:", currentCallId);

                // 5. Listen for answer from the callee
                callEndedListener = onValue(ref(db, `calls/${currentCallId}`), async (snapshot) => {
                    const callData = snapshot.val();
                    if (!callData) return; // Call might have been deleted

                    if (callData.status === 'answered' && callData.answer && peerConnection.remoteDescription?.type !== 'answer') {
                        console.log("Received answer:", callData.answer);
                        // Set the remote description with the answer
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.answer));
                        callStatus.textContent = 'Connecting...';
                        hideLoading();
                        showSection('call-screen'); // Show call screen
                    } else if (callData.status === 'rejected') {
                        hideLoading();
                        showAlert("Call Rejected", `${callData.calleeUsername} rejected your call.`);
                        hangupCall();
                    } else if (callData.status === 'no-answer') {
                        hideLoading();
                        showAlert("No Answer", `${callData.calleeUsername} did not answer.`);
                        hangupCall();
                    } else if (callData.status === 'ended' && callData.endedBy !== currentUser.uid) {
                        hideLoading();
                        showAlert("Call Ended", `${callData.endedByUsername || 'The other party'} ended the call.`);
                        hangupCall();
                    }
                });

                // 6. Listen for ICE candidates from the callee
                onChildAdded(ref(db, `calls/${currentCallId}/candidates/${targetUser.uid}`), (snapshot) => {
                    const candidate = new RTCIceCandidate(snapshot.val());
                    console.log("Adding remote ICE candidate:", candidate);
                    peerConnection.addIceCandidate(candidate);
                });

                // Update call UI
                remoteUserDisplay.textContent = `Calling ${targetUser.username}...`;
                callStatus.textContent = 'Ringing...';

                // Set a timeout for no answer (e.g., 30 seconds)
                setTimeout(async () => {
                    const currentCallSnapshot = await get(ref(db, `calls/${currentCallId}`));
                    if (currentCallSnapshot.exists() && currentCallSnapshot.val().status === 'ringing') {
                        // If still ringing after timeout, update status to 'no-answer'
                        update(ref(db, `calls/${currentCallId}`), { status: 'no-answer', endedBy: 'system' });
                    }
                }, 30000); // 30 seconds

                hideLoading();
                showSection('call-screen'); // Show call screen immediately for outgoing call
            } catch (error) {
                console.error("Error starting outgoing call:", error);
                hideLoading();
                showAlert("Call Error", "Failed to start call: " + error.message);
                hangupCall(); // Clean up if an error occurs
            }
        };

        /**
         * Listens for incoming calls directed to the current user.
         */
        window.listenForIncomingCalls = function() {
            if (!currentUser || !currentUser.uid) {
                console.warn("Not logged in, cannot listen for calls.");
                return;
            }

            const callsRef = ref(db, 'calls');
            // Listen for new calls where this user is the callee and status is 'ringing'
            // Using onChildAdded to detect new call entries
            onChildAdded(callsRef, async (snapshot) => {
                const callData = snapshot.val();
                const callId = snapshot.key;

                if (callData.calleeId === currentUser.uid && callData.status === 'ringing') {
                    console.log("Incoming call detected:", callData);

                    if (currentCallId) {
                        // If already in a call or busy, reject new incoming call automatically
                        console.log("Already in a call, rejecting new incoming call.");
                        update(ref(db, `calls/${callId}`), { status: 'rejected', endedBy: currentUser.uid, endedByUsername: currentUser.username });
                        return;
                    }

                    currentCallId = callId; // Set the current active call ID
                    callRef = ref(db, `calls/${callId}`); // Set the Firebase reference
                    callType = callData.type; // Store the call type

                    // Show incoming call prompt
                    const answerCall = await showPrompt(
                        "Incoming Call",
                        `Incoming ${callData.type} call from ${callData.callerUsername}. Do you want to answer?`,
                        false, // No input needed
                        "Answer",
                        "Reject"
                    );

                    if (answerCall) {
                        showLoading("Answering call...");
                        try {
                            // 1. Get local media stream
                            if (!await getLocalStream(callType === 'video')) {
                                // If stream fails, reject the call and clean up
                                update(ref(db, `calls/${callId}`), { status: 'rejected', endedBy: currentUser.uid, endedByUsername: currentUser.username });
                                hideLoading();
                                hangupCall();
                                return;
                            }

                            // 2. Create RTCPeerConnection
                            createPeerConnection();

                            // 3. Set remote offer from the caller
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
                            console.log("Set remote offer.");

                            // 4. Create SDP answer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            console.log("Created and set local answer.");

                            // 5. Update call in Firebase with answer and status
                            await update(ref(db, `calls/${callId}`), {
                                answer: {
                                    type: answer.type,
                                    sdp: answer.sdp,
                                },
                                status: 'answered' // Change status to answered
                            });
                            console.log("Call answered and updated in Firebase.");

                            // 6. Listen for ICE candidates from the caller
                            onChildAdded(ref(db, `calls/${callId}/candidates/${callData.callerId}`), (snapshot) => {
                                const candidate = new RTCIceCandidate(snapshot.val());
                                console.log("Adding remote ICE candidate:", candidate);
                                peerConnection.addIceCandidate(candidate);
                            });

                            // 7. Listen for the caller ending the call (status change to 'ended' or 'no-answer'/'rejected')
                            callEndedListener = onValue(ref(db, `calls/${callId}`), (snap) => {
                                const updatedCallData = snap.val();
                                if (!updatedCallData || updatedCallData.status === 'ended' || updatedCallData.status === 'no-answer' || updatedCallData.status === 'rejected') {
                                    // Only show alert if the other party ended it, not if this user hung up
                                    if (updatedCallData && updatedCallData.endedBy !== currentUser.uid) {
                                        showAlert("Call Ended", `${updatedCallData.endedByUsername || 'The other party'} ended the call.`);
                                    }
                                    hangupCall(); // Clean up and return to previous screen
                                }
                            });

                            // Update call UI
                            remoteUserDisplay.textContent = `Connected with ${callData.callerUsername}`;
                            callStatus.textContent = 'Connecting...'; // Will change to 'Connected!' on track event
                            hideLoading();
                            showSection('call-screen'); // Show call screen
                        } catch (error) {
                            console.error("Error answering call:", error);
                            hideLoading();
                            showAlert("Call Error", "Failed to answer call: " + error.message);
                            // If an error occurs during answer, reject the call in Firebase
                            update(ref(db, `calls/${callId}`), { status: 'rejected', endedBy: currentUser.uid, endedByUsername: currentUser.username });
                            hangupCall();
                        }
                    } else {
                        // User rejected the call
                        console.log("Call rejected by user.");
                        update(ref(db, `calls/${callId}`), { status: 'rejected', endedBy: currentUser.uid, endedByUsername: currentUser.username });
                        hangupCall(); // Clean up local state
                    }
                }
            });
            console.log("Listening for incoming calls...");
        };

        /**
         * Hangs up the current call and cleans up all WebRTC and Firebase resources.
         */
        window.hangupCall = async function() {
            // 1. Update call status in Firebase (if a call is active)
            if (callRef && currentCallId && currentUser && currentUser.uid) {
                console.log("Hanging up call:", currentCallId);
                // Set status to 'ended' and indicate who ended it
                await update(ref(db, `calls/${currentCallId}`), {
                    status: 'ended',
                    endedBy: currentUser.uid,
                    endedByUsername: currentUser.username // Assuming currentUser has username
                });
                // Detach the Firebase listener to prevent re-triggering hangup
                if (callEndedListener) {
                    callEndedListener(); // Call the unsubscribe function returned by onValue
                    callEndedListener = null;
                }
            }

            // 2. Close RTCPeerConnection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                console.log("PeerConnection closed.");
            }

            // 3. Stop local media stream
            stopLocalStream();

            // 4. Reset video elements
            remoteVideo.srcObject = null;
            remoteVideo.style.display = 'none'; // Hide remote video
            localVideo.style.display = 'none'; // Hide local video

            // 5. Reset UI elements and state variables
            callStatus.textContent = '';
            remoteUserDisplay.textContent = '';
            currentCallId = null;
            callRef = null;
            callType = null;
            isMicMuted = false;
            isVideoOff = false;
            toggleMicBtn.classList.remove('off');
            toggleVideoBtn.classList.remove('off');
            toggleVideoBtn.style.display = 'flex'; // Reset display for video toggle button

            // 6. Return to the group options section (or contacts section, depending on where the call was initiated)
            // This part assumes showSection is available and manages main app sections.
            // For standalone call.html, this would just hide the call screen.
            showSection('contacts-section'); // Default back to contacts after a call
            console.log("Call cleaned up.");
        };

        /**
         * Toggles the microphone mute state and updates the UI.
         */
        function toggleMic() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state
                    isMicMuted = !track.enabled; // Update mute state variable
                    updateCallUI(); // Update button appearance
                    console.log(`Mic ${isMicMuted ? 'muted' : 'unmuted'}`);
                });
            }
        }

        /**
         * Toggles the video on/off state and updates the UI.
         * Only applicable if the call is a video call.
         */
        function toggleVideo() {
            // Only toggle video if localStream exists and it's a video call
            if (localStream && callType === 'video') {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state
                    isVideoOff = !track.enabled; // Update video off state variable
                    // Hide local video element if video is off
                    localVideo.style.opacity = isVideoOff ? '0' : '1';
                    updateCallUI(); // Update button appearance
                    console.log(`Video ${isVideoOff ? 'off' : 'on'}`);
                });
            }
        }

        /**
         * Updates the visual state of call control buttons (mute/video off icons).
         */
        function updateCallUI() {
            if (isMicMuted) {
                toggleMicBtn.classList.add('off');
            } else {
                toggleMicBtn.classList.remove('off');
            }

            if (isVideoOff) {
                toggleVideoBtn.classList.add('off');
            } else {
                toggleVideoBtn.classList.remove('off');
            }
        }

        // Event Listeners for Call Buttons
        toggleMicBtn.addEventListener('click', toggleMic);
        toggleVideoBtn.addEventListener('click', toggleVideo);
        hangupBtn.addEventListener('click', hangupCall);
        backFromCallBtn.addEventListener('click', hangupCall); // Back button also hangs up

        // Auth state handler for currentUser (minimal for standalone call.html)
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                const snapshot = await get(child(ref(db), `users/${user.uid}`));
                if (snapshot.exists()) {
                    currentUser = { ...user, ...snapshot.val() };
                    console.log("User logged in in call.html context:", currentUser.username);
                    // Automatically start listening for calls if user is logged in
                    listenForIncomingCalls();
                }
            } else {
                currentUser = null;
                console.log("User logged out in call.html context.");
            }
        });

        // Initially hide the call screen
        document.addEventListener('DOMContentLoaded', () => {
            callScreen.style.display = 'none';
            // If running standalone, you might want a button to trigger a test call
            // For integration into ThunderChat, main.js will manage showing/hiding.
        });
    </script>
</body>
</html>
